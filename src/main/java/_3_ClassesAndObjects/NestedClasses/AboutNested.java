package _3_ClassesAndObjects.NestedClasses;

/**
 * Язык программирования Java позволяет вам определять класс
 * в другом классе. Такой класс называется вложенным классом:
     * class OuterClass {
     *     ...
     *     class NestedClass {
     *         ...
     *     }
     * }
 * Терминология: вложенные классы делятся на две категории:
 *  статические и нестатические. Вложенные классы, которые
 *  объявлены статическими, называются статическими вложенными
 *  классами. Нестатические вложенные классы называются внутренними
 *  классами.
     * class OuterClass {
     *     ...
     *     static class StaticNestedClass {
     *         ...
     *     }
     *     class InnerClass {
     *         ...
     *     }
     * }
 * Вложенный класс является членом включающего его класса.
 * Нестатические вложенные классы (внутренние классы) имеют
 * доступ к другим членам включающего класса, даже если они
 * объявлены закрытыми. Статические вложенные классы не имеют
 * доступа к другим членам включающего класса. Как член
 * OuterClass, вложенный класс может быть объявлен закрытым,
 * открытым, защищенным или закрытым. (Напомним, что внешние
 * классы могут быть объявлены только как public или package
 * private.)
 * ---------- Зачем использовать вложенные классы? ----------
 * Необоснованные причины использования вложенных классов:
 * - Это способ логически сгруппировать классы, которые используются
 *   только в одном месте: если класс полезен только для
 *   одного другого класса, то логично встраивать его в этот
 *   класс и сохранять их вместе. Вложение таких «вспомогательных
 *   классов» делает их пакет более упорядоченным.
 * - Это увеличивает инкапсуляцию: рассмотрим два класса верхнего
 *   уровня, A и B, где B необходим доступ к членам A, которые
 *   в противном случае были бы объявлены закрытыми. Скрывая
 *   класс B в классе A, члены A могут быть объявлены частными,
 *   и B может получить к ним доступ. Кроме того, сам B может
 *   быть скрыт от внешнего мира.
 * - Это может привести к более удобочитаемому и поддерживаемому
 *   коду: вложение небольших классов в классы верхнего уровня
 *   размещает код ближе к месту его использования.
 *
 * ------------- Статические Вложенные Классы ---------------
 * Как и в случае методов и переменных класса, статический
 * вложенный класс связан с его внешним классом. И, как и
 * методы статического класса, статический вложенный класс
 * не может напрямую ссылаться на переменные экземпляра или
 * методы, определенные вo включающем его классе: он может
 * использовать их только через ссылку на объект.
 *   Примечание. Статический вложенный класс взаимодействует
 *   с членами экземпляра своего внешнего класса (и других
 *   классов), как и любой другой класс верхнего уровня.
 *   По сути, статический вложенный класс является поведенческим
 *   классом верхнего уровня, который был вложен в другой
 *   класс верхнего уровня для удобства упаковки.
 * Доступ к статическим вложенным классам осуществляется с
 * использованием имени включающего класса:
 *      OuterClass.StaticNestedClass
 * Например, чтобы создать объект для статического вложенного
 * класса, используйте этот синтаксис:
 *      OuterClass.StaticNestedClass nestedObject =
 *          new OuterClass.StaticNestedClass();
 *
 * --------------- Внутренние классы ----------------------
 * Как и в случае методов и переменных экземпляра, внутренний
 * класс связан с экземпляром включающего его класса и имеет
 * прямой доступ к методам и полям этого объекта. Кроме того,
 * поскольку внутренний класс связан с экземпляром, он не
 * может сам определять какие-либо статические члены.
 * Объекты, которые являются экземплярами внутреннего класса,
 * существуют в экземпляре внешнего класса. Рассмотрим следующие
 * классы:
     * class OuterClass {
     *     ...
     *     class InnerClass {
     *         ...
     *     }
     * }
 * Экземпляр InnerClass может существовать только внутри
 * экземпляра OuterClass и имеет прямой доступ к методам и
 * полям его включающего экземпляра.
 * Чтобы создать экземпляр внутреннего класса, вы должны
 * сначала создать экземпляр внешнего класса. Затем создайте
 * внутренний объект во внешнем объекте с этим синтаксисом:
 *      OuterClass.InnerClass innerObject =
 *          outerObject.new InnerClass();
 * Существует два специальных вида внутренних классов:
 * локальные классы и анонимные классы.
 *
 * -------------------- Затенение ------------------------
 * Если объявление типа (такого как переменная-член или имя параметра) в определенной области (например, внутренний класс или определение метода) имеет то же имя, что и другое объявление во вмещающей области, то объявление затеняет объявление ограждающей области. Вы не можете ссылаться на скрытую декларацию только по ее имени. Следующий пример, ShadowTest, демонстрирует это:
     * public class ShadowTest {
     *
     *     public int x = 0;
     *
     *     class FirstLevel {
     *
     *         public int x = 1;
     *
     *         void methodInFirstLevel(int x) {
     *             System.out.println("x = " + x);
     *             System.out.println("this.x = " + this.x);
     *             System.out.println("ShadowTest.this.x = "
 *                                    + ShadowTest.this.x);
     *         }
     *     }
     *
     *     public static void main(String... args) {
     *         ShadowTest st = new ShadowTest();
     *         ShadowTest.FirstLevel fl = st.new FirstLevel();
     *         fl.methodInFirstLevel(23);
     *     }
     * }
 * Ниже приведен вывод этого примера:
     * x = 23
     * this.x = 1
     * ShadowTest.this.x = 0
 * В этом примере определяются три переменные с именем x: переменная-член класса ShadowTest, переменная-член внутреннего класса FirstLevel и параметр в методе methodInFirstLevel. Переменная x, определенная как параметр метода methodInFirstLevel, затеняет переменную внутреннего класса FirstLevel. Следовательно, когда вы используете переменную x в методе methodInFirstLevel, он ссылается на параметр метода. Чтобы сослаться на переменную-член внутреннего класса FirstLevel, используйте ключевое слово this, чтобы представить охватывающую область:
 *      System.out.println("this.x = " + this.x);
 * Обратитесь к переменным-членам, которые охватывают большие области по имени класса, к которому они принадлежат. Например, следующий оператор обращается к переменной-члену класса ShadowTest из метода methodInFirstLevel:
 *    System.out.println("ShadowTest.this.x = "
 *                       + ShadowTest.this.x);
 *
 * ----------------
 *
 *
 */
public class AboutNested {
}


