package _3_ClassesAndObjects.Classes;

/**
 * Класс содержит конструкторы, которые вызываются для создания
 * объектов из чертежа класса. Объявления конструктора выглядят
 * как объявления методов, за исключением того, что они
 * используют имя класса и не имеют возвращаемого типа.
 * Например, Bicycle имеет один конструктор:
 */ /*
public Bicycle(int startGear, int startCadence, int startSpeed) {
    gear = startGear;
    cadence = startCadence;
    speed = startSpeed;
}   */
/**
 * Чтобы создать новый объект Bicycle с именем myBike, новый
 * оператор вызывает конструктор:
 *  Bicycle myBike = new Bicycle(30, 0, 8);
 *
 * new Bicycle(30, 0, 8) создает пространство в памяти для
 * объекта и инициализирует его поля.
 * Хотя Bicycle имеет только один конструктор, он может
 * иметь и другие, включая конструктор без аргументов:
     * public Bicycle() {
     *     gear = 1;
     *     cadence = 10;
     *     speed = 0;
     * }
 * Bicycle yourBike = new Bicycle(); вызывает конструктор
 * без аргументов для создания нового объекта Bicycle с
 * именем yourBike.
 * Оба конструктора могли быть объявлены в Bicycle, потому
 * что они имеют разные списки аргументов. Как и в случае
 * с методами, платформа Java различает конструкторы по
 * количеству аргументов в списке и их типам. Вы не можете
 * написать два конструктора, которые имеют одинаковое число
 * и тип аргументов для одного и того же класса, потому что
 * платформа не сможет их различить. Это вызывает ошибку во
 * время компиляции.
 * Вам не нужно предоставлять конструкторы для вашего класса,
 * но вы должны быть осторожны при этом. Компилятор автоматически
 * предоставляет конструктор по умолчанию без аргументов
 * для любого класса без конструкторов. Этот конструктор
 * по умолчанию вызовет конструктор суперкласса без аргументов.
 * В этой ситуации компилятор будет жаловаться, если у суперкласса
 * нет конструктора без аргументов, поэтому вы должны убедиться,
 * что он есть. Если у вашего класса нет явного суперкласса,
 * то у него есть неявный суперкласс Object, у которого есть
 * конструктор без аргументов.
 * Вы можете использовать конструктор суперкласса самостоятельно.
 * Вы можете использовать модификаторы доступа в объявлении
 * конструктора, чтобы контролировать, какие другие классы
 * могут вызывать конструктор.
 *  Примечание. Если другой класс не может вызвать конструктор
 *          MyClass, он не может напрямую создавать объекты
 *          MyClass.
 */
public class ProvidingConstructors {
}
