package _2_LanguageBasic.Variables;

/**
 * Массив - это контейнерный объект, который содержит фиксированное
 * количество значений одного типа. Длина массива устанавливается
 * при его создании. После создания его длина фиксируется.
 * Каждый элемент в массиве называется элементом, и каждый
 * элемент доступен по его числовому индексу. Например, 9-й
 * элемент будет доступен по индексу 8.
 * Следующая программа, ArrayDemo, создает массив целых чисел,
 * помещает некоторые значения в массив и печатает каждое
 * значение в стандартный вывод.
 */
public class ArrayDataType {
    public static void main(String[] args) {
        // declare an array of integers
        int[] anArray;

        // allocates memory for 10 integers
        anArray = new int[10];

        // initialise first element
        anArray[0] = 100;
        // init. second el.
        anArray[1] = 200;
        // and so forth
        anArray[2] = 300;
        anArray[3] = 400;
        anArray[4] = 500;
        anArray[5] = 600;
        anArray[6] = 700;
        anArray[7] = 800;
        anArray[8] = 900;
        anArray[9] = 1000;

        System.out.println("Elem at index 0: " +anArray[0]);
        System.out.println("Elem at index 0: " +anArray[1]);
        System.out.println("Elem at index 0: " +anArray[2]);
    }
}
/**
 * Elem at index 0: 100
 * Elem at index 0: 200
 * Elem at index 0: 300
 * ---------------------------------------------------------
 * Declaring a Variable to Refer to an Array
 * Как и объявления для переменных других типов, объявление
 * массива имеет два компонента: тип массива и имя массива.
 * Тип массива записывается как type [], где type - тип данных
 * содержащихся элементов; скобки - это специальные символы,
 * указывающие, что эта переменная содержит массив. Размер массива
 * не является частью его типа (поэтому квадратные скобки пусты).
 * Имя массива может быть любым, если вы хотите, при условии,
 * что оно соответствует правилам и соглашениям, как уже обсуждалось
 * в разделе именования. Как и с переменными других типов,
 * объявление фактически не создает массив; он просто сообщает
 * компилятору, что эта переменная будет содержать массив
 * указанного типа.
 * Вы также можете поместить скобки после имени массива:
 *      // эта форма не рекомендуется
 *      float anArrayOfFloats[];
 * Тем не менее, конвенция препятствует этой форме; скобки
 * обозначают тип массива и должны отображаться с обозначением
 * типа.
 *
 * -----Creating, Initializing, and Accessing an Array-----
 * Создание, инициализация и доступ к массиву.
 * Один из способов создать массив - использовать оператор new.
 * Следующий оператор в программе ArrayDemo выделяет массив
 * с достаточным объемом памяти для 10 целочисленных элементов
 * и присваивает массив переменной anArray.
 * Каждый элемент массива доступен по его числовому индексу
 * Кроме того, вы можете использовать синтаксис ярлыка для
 * создания и инициализации массива
     * int[] anArray = {
     *     100, 200, 300,
     *     400, 500, 600,
     *     700, 800, 900, 1000
     * };
 * Здесь длина массива определяется количеством значений,
 * заключенных в фигурные скобки и разделенных запятыми.
 * Также можно объявить массив массивов (также известный как
 * многомерный массив) с помощью двух или более наборов скобок,
 * таких как имена String[][]. Следовательно, каждый элемент
 * должен иметь доступ к соответствующему количеству значений
 * индекса.
 * В Java многомерный массив - это массив, компоненты которого
 * сами являются массивами. Это не похоже на массивы в C или
 * Fortran. Следствием этого является то, что длина строк
 * может изменяться, как показано в следующей программе MultiDimArrayDemo:
 */
class MultiDimArrayDemo {
    public static void main(String[] args) {
        String[][] names = {
                {"Mr. ", "Mrs. ", "Ms. "},
                {"Smith", "Jones"}
        };
        // Mr. Smith
        System.out.println(names[0][0] + names[1][0]);
        // Ms. Jones
        System.out.println(names[0][2] + names[1][1]);
    }
}
/**
 * Mr. Smith
 * Ms. Jones
 * Наконец, вы можете использовать встроенное свойство длины,
 * чтобы определить размер любого массива. Следующий код выводит
 * размер массива на стандартный вывод:
 *       System.out.println(anArray.length);
 *
 * -----Copying Arrays-----
 * Класс System имеет метод arraycopy, который можно использовать
 * для эффективного копирования данных из одного массива в другой
 *   public static void arraycopy(Object src, int srcPos,
 *                              Object dest, int destPos,
 *                              int length);
 * Два аргумента Object указывают массив для копирования "из"
 * и массив для копирования "в". Три аргумента int указывают
 * начальную позицию в исходном массиве, начальную позицию
 * в целевом массиве и количество копируемых элементов массива.
 * Следующая программа, ArrayCopyDemo, объявляет массив элементов
 * типа char, произносящих слово «decaffeinated». Он использует
 * метод System.arraycopy для копирования подпоследовательности
 * компонентов массива во второй массив:
 */
class ArrayCopyDemo {
    public static void main(String[] args) {
        char[] copyFrom = { 'd', 'e', 'c', 'a', 'f', 'f', 'e',
                'i', 'n', 'a', 't', 'e', 'd' };
        char[] copyTo = new char[7];

        System.arraycopy(copyFrom, 2, copyTo, 0, 7);
        System.out.println(new String(copyTo));
    }
}// >>> caffein
/**
 * Array Manipulations
 * Для вашего удобства Java SE предоставляет несколько методов
 * для выполнения манипуляций с массивами (общие задачи, такие
 * как копирование, сортировка и поиск массивов) в классе
 * java.util.Arrays. Например, предыдущий пример можно изменить,
 * чтобы использовать метод copyOfRange класса java.util.Arrays,
 * как вы можете видеть в примере ArrayCopyOfDemo. Разница в
 * том, что использование метода copyOfRange не требует создания
 * массива назначения перед вызовом метода, потому что метод
 * возвращает массив назначения:
 */
class ArrayCopyOfDemo {
    public static void main(String[] args) {
        char[] copyFrom = {'d', 'e', 'c', 'a', 'f', 'f',
                'e', 'i', 'n', 'a', 't', 'e', 'd'};
        char[] copyTo = java.util.Arrays.copyOfRange(
                copyFrom, 2, 9);

        System.out.println(new String(copyTo));
    }
}
/**
 * Как видно, вывод этой программы одинаковый (caffein),
 * хотя для него требуется меньше строк кода. Обратите внимание,
 * что второй параметр метода copyOfRange - это начальный индекс
 * диапазона, который будет скопирован включительно, в то
 * время как третий параметр - это конечный индекс исключительно
 * диапазона, который будет скопирован. В этом примере копируемый
 * диапазон не включает элемент массива с индексом 9 (который
 * содержит символ a).
 * Некоторые другие полезные операции, предоставляемые методами
 * в классе java.util.Arrays:
 * - Поиск в массиве определенного значения для получения индекса,
 *   в котором он размещен (binarySearch method).
 * - Сравнение двух массивов, чтобы определить, равны они
 *   или нет (метод equals).
 * - Заполнение массива для размещения определенного значения
 *   в каждом индексе (метод fill).
 * - Сортировка массива в порядке возрастания. Это можно сделать
 *   либо последовательно, используя метод  sort, либо
 *   одновременно, используя метод  parallelSort, представленный
 *   в Java SE 8. Параллельная сортировка больших массивов
 *   в многопроцессорных системах быстрее, чем последовательная
 *   сортировка массивов.
 * --------------------------------------------------------------
 * Summary of Variables
 * Язык программирования Java использует как «поля», так и
 * «переменные» как часть своей терминологии. Переменные экземпляра
 * (нестатические поля) уникальны для каждого экземпляра класса.
 * Переменные класса (статические поля) - это поля, объявленные
 * с модификатором static; существует ровно одна копия переменной
 * класса, независимо от того, сколько раз был создан экземпляр
 * класса. Локальные переменные хранят временное состояние
 * внутри метода. Параметры - это переменные, которые предоставляют
 * дополнительную информацию методу; как локальные переменные,
 * так и параметры всегда классифицируются как «переменные»
 * (а не «поля»). При именовании ваших полей или переменных
 * существуют правила и соглашения, которым вы должны (или
 * надо) следовать.
 * Восемь примитивных типов данных: byte, short, int, long,
 * float, double, boolean, char. Класс java.lang.String представляет
 * символьные строки. Компилятор назначит разумное значение
 * по умолчанию для полей вышеуказанных типов; для локальных
 * переменных значение по умолчанию никогда не назначается.
 * Литерал - это представление исходного кода с фиксированным
 * значением. Массив - это контейнерный объект, который содержит
 * фиксированное количество значений одного типа. Длина массива
 * устанавливается при его создании. После создания его длина
 * фиксируется.
 */

































