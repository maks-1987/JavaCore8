package _2_LanguageBasic.Variables;

/**
 * Java является статически типизированным, что означает, что
 * все переменные должны быть сначала объявлены, прежде чем
 * их можно будет использовать.
 *  Это говорит вашей программе, что поле с именем «gear»
 * существует, содержит числовые данные и имеет начальное
 * значение «1». Тип данных переменной определяет значения,
 * которые она может содержать, плюс операции, которые могут
 * быть выполнены с ней. В дополнение к int, Java поддерживает
 * семь других примитивных типов данных. Тип примитива предопределен
 * языком и называется зарезервированным ключевым словом.
 * Примитивные значения не разделяют состояние с другими
 * примитивными значениями. Восемь примитивных типов данных,
 * поддерживаемых языком программирования Java:
 * - byte. Байтовый тип данных представляет собой 8-разрядное
 *        целое число со знаком в виде двоичного числа со
 *        знаком. Он имеет минимальное значение -128 и максимальное
 *        значение 127 (включительно). Байтовый тип данных
 *        может быть полезен для сохранения памяти в больших
 *        массивах, где экономия памяти действительно имеет
 *        значение. Их также можно использовать вместо int,
 *        где их пределы помогают уточнить ваш код; тот факт,
 *        что диапазон переменной ограничен, может служить
 *        формой документации.
 * - short. Короткий тип данных - это 16-разрядное целое
 *        число со знаком в виде двоичного числа со знаком.
 *        Он имеет минимальное значение -32 768 и максимальное
 *        значение 32 767 (включительно). Как и в случае с
 *        байтом, применяются те же правила: вы можете использовать
 *        short для экономии памяти в больших массивах в
 *        ситуациях, когда экономия памяти действительно имеет
 *        значение.
 * - int. По умолчанию тип данных int представляет собой
 *        32-разрядное целое число с двоичным знаком со знаком,
 *        минимальное значение которого равно -2*e31, а максимальное -
 *        2*31-1. В Java SE 8 и более поздних версиях вы можете
 *        использовать тип данных int для представления
 *        32-разрядного целого числа без знака, которое
 *        имеет минимальное значение 0 и максимальное значение
 *        2*e32-1. Используйте класс Integer, чтобы использовать
 *        тип данных int как целое число без знака.
 *        Статические методы, такие как compareUnsigned,
 *        splitUnsigned и т. Д., Были добавлены в класс
 *        Integer для поддержки арифметических операций
 *        для целых чисел без знака.
 * - long. Это 64-разрядное целое число с дополнением до
 *        двух. Подписанный long имеет минимальное значение
 *        -2*e63 и максимальное значение 2*e63-1. В Java SE 8
 *        и более поздних версиях вы можете использовать тип
 *        данных long для представления 64-битной длины
 *        без знака, которая имеет минимальное значение
 *        0 и максимальное значение 2*e64-1. Используйте этот
 *        тип данных, когда вам нужен диапазон значений,
 *        более широкий, чем тот, который предоставляет
 *        int. Класс Long также содержит методы, такие как
 *        compareUnsigned ,divUnsigned и т. Д. Для поддержки
 *        арифметических операций для длинных без знака.
 * - float. Тип данных с плавающей запятой - это 32-битная
 *        IEEE 754 с плавающей запятой одинарной точности.
 *        Его диапазон значений выходит за рамки этого обсуждения,
 *        но указан в разделе «Типы, форматы и значения с
 *        плавающей запятой» в спецификации языка Java.
 *        Как и в случае с рекомендациями для байтов и
 *        коротких символов, используйте число с плавающей
 *        запятой (вместо двойного), если вам нужно экономить
 *        память в больших массивах чисел с плавающей запятой.
 *        Этот тип данных никогда не должен использоваться
 *        для точных значений, таких как валюта. Для этого
 *        вам нужно будет использовать класс java.math.BigDecimal.
 *        Numbers and Strings охватывает BigDecimal и другие
 *        полезные классы, предоставляемые платформой Java.
 * - double. Двойной тип данных представляет собой 64-битную
 *        IEEE 754 с плавающей запятой двойной точности.
 *        Для десятичных значений этот тип данных обычно является
 *        выбором по умолчанию. Как упоминалось выше, этот
 *        тип данных никогда не должен использоваться для
 *        точных значений, таких как валюта
 * - boolean. Логический тип данных имеет только два возможных
 *        значения: true и false. Используйте этот тип данных
 *        для простых флагов, которые отслеживают истинные/ложные
 *        условия. Этот тип данных представляет один бит
 *        информации, но его «размер» не является чем-то
 *        точно определенным.
 * - char. Тип данных char - это один 16-битный символ Unicode.
 *        Он имеет минимальное значение «\u0000» (или 0) и
 *        максимальное значение «\uffff» (или 65 535 включительно).
 * В дополнение к восьми перечисленным выше примитивным типам
 * данных язык Java также обеспечивает специальную поддержку
 * для символьных строк через класс java.lang.String. Заключение
 * строки символов в двойные кавычки автоматически создаст
 * новый объект String; например, String s = "это строка" ;.
 * Строковые объекты являются неизменяемыми, что означает,
 * что после создания их значения не могут быть изменены.
 * Класс String технически не является примитивным типом
 * данных, но, учитывая особую поддержку, оказываемую ему
 * языком, вы, вероятно, будете думать о нем как таковом.
 */
public class PrimitiveDataType {
     int gear = 1;
}
/**
 * Default Values (Значения по умолчанию)
 * Не всегда необходимо присваивать значение при объявлении
 * поля. Поля, которые объявлены, но не инициализированы,
 * будут установлены разумным значением по умолчанию компилятором.
 * Вообще говоря, это значение по умолчанию будет нулевым или
 * null, в зависимости от типа данных. Однако полагаться на
 * такие значения по умолчанию считается плохим стилем программирования.
      * byte 	    0
      * short 	    0
      * int 	    0
      * long 	    0L
      * float 	    0.0f
      * double 	    0.0d
      * char 	    '\u0000'
      * String (or any object)   	null
      * boolean 	false
 * Локальные переменные немного отличаются; компилятор никогда
 * не назначает значение по умолчанию для неинициализированной
 * локальной переменной. Если вы не можете инициализировать
 * локальную переменную там, где она объявлена, убедитесь,
 * что присвоили ей значение, прежде чем пытаться ее использовать.
 * Доступ к неинициализированной локальной переменной приведет к
 * ошибке во время компиляции.
 *   -----Literals-----
 * Возможно, вы заметили, что новое ключевое слово не используется
 * при инициализации переменной примитивного типа. Примитивные
 * типы - это специальные типы данных, встроенные в язык;
 * они не являются объектами, созданными из класса. Литерал -
 * это представление исходного кода фиксированного значения;
 * Литералы представлены непосредственно в вашем коде, не
 * требуя вычислений. Как показано ниже, можно присвоить литерал
 * переменной примитивного типа:
      * boolean result = true;
      * char capitalC = 'C';
      * byte b = 100;
      * short s = 10000;
      * int i = 100000;
 *
 *   -----Integer Literals-----
 * Целочисленный литерал имеет тип long, если он заканчивается
 * буквой L или l; в противном случае он имеет тип int. Рекомендуется
 * использовать заглавную букву L, потому что строчную букву
 * l трудно отличить от цифры 1.
 * Значения целочисленных типов byte, short, int и long могут
 * быть созданы из литералов int. Значения типа long, которые
 * превышают диапазон int, могут быть созданы из длинных
 * литералов. Целочисленные литералы могут быть выражены
 * этими системами счисления:
 * - Decimal: основание 10, цифры которого состоят из чисел
 *   от 0 до 9; это система счисления, которую вы используете
 *   каждый день
 * - Hexadecimal: основание 16, чьи цифры состоят из цифр
 *   от 0 до 9 и букв от A до F
 * - Binary: основание 2, чьи цифры состоят из чисел 0
 *   и 1 (вы можете создавать двоичные литералы в Java SE 7
 *   и более поздних версиях)
 * Для программирования общего назначения десятичная система,
 * вероятно, будет единственной системой счисления, которую вы
 * когда-либо будете использовать. Однако, если вам нужно
 * использовать другую систему счисления, в следующем примере
 * показан правильный синтаксис. Префикс 0x обозначает шестнадцатеричный
 * код, а 0b обозначает двоичный:
      * // The number 26, in decimal
      * int decVal = 26;
      * //  The number 26, in hexadecimal
      * int hexVal = 0x1a;
      * // The number 26, in binary
      * int binVal = 0b11010;
 *
 * -----Floating-Point Literals-----
 * Литерал с плавающей точкой имеет тип float, если он заканчивается
 * буквой F или f; в противном случае его тип является
 * двойным, и он может заканчиваться буквой D или d.
 * Типы с плавающей запятой (float и double) также могут
 * быть выражены с помощью E или e (для научной нотации),
 * F или f (32-битный литерал с плавающей запятой) и D или
 * d (64-битный двойной литерал; это значение по умолчанию
 * и соглашение опущено).
      * double d1 = 123.4;
      * // same value as d1, but in scientific notation
      * double d2 = 1.234e2;
      * float f1  = 123.4f;
 *
 * -----Character and String Literals-----
 * Литералы типов char и String могут содержать любые символы
 * Unicode (UTF-16). Если ваш редактор и файловая система
 * позволяют это, вы можете использовать такие символы прямо
 * в своем коде. Если нет, вы можете использовать «Unicode
 * escape», такой как «\u0108» (заглавная C с круговым сплетением)
 * или «S \u00ED Se \u00F1or» (Sí Señor по-испански). Всегда
 * используйте «одинарные кавычки» для литералов символов
 * и «двойные кавычки» для литералов String. Экранирующие
 * последовательности Unicode могут использоваться в других
 * местах программы (например, в именах полей), а не только
 * в литералах char или String.
 * Java также поддерживает несколько специальных escape-последовательностей
 * для литералов char и String: \b (возврат на одну позицию),
 * \t (табуляция), \n (перевод строки), \f (перевод формы),
 * \r (возврат каретки), \"(двойная кавычка), \'(одинарная
 * кавычка) и \\ (обратная косая черта).
 * Существует также специальный null литерал, который можно
 * использовать в качестве значения для любого ссылочного
 * типа.
 * Null может быть назначен любой переменной, кроме переменных
 * примитивных типов. Вы можете мало что сделать с нулевым
 * значением, кроме проверки его присутствия. Следовательно,
 * null часто используется в программах в качестве маркера,
 * чтобы указать, что какой-то объект недоступен.
 * Наконец, есть также особый тип литерала, называемый литералом
 * класса, сформированный путем взятия имени типа и добавления
 * «.class»; например, String.class. Это относится к объекту
 * (типа Class), который представляет сам тип.
 *
 * -----Using Underscore Characters in Numeric Literals-----
 * Использование символов подчеркивания в числовых литералах
 * В Java SE 7 и более поздних версиях любое число символов
 * подчеркивания (_) может появляться в любом месте между
 * цифрами в числовом литерале. Эта функция позволяет вам,
 * например. разделять группы цифр в числовых литералах,
 * что может улучшить читаемость вашего кода.
 * Например, если ваш код содержит числа с несколькими цифрами,
 * вы можете использовать символ подчеркивания для разделения
 * цифр на группы по три, аналогично тому, как вы бы использовали
 * знак пунктуации, например, запятую или пробел в качестве
 * разделителя.
 * В следующем примере показаны другие способы использования
 * подчеркивания в числовых литералах:
     * long creditCardNumber = 1234_5678_9012_3456L;
     * long socialSecurityNumber = 999_99_9999L;
     * float pi =  3.14_15F;
     * long hexBytes = 0xFF_EC_DE_5E;
     * long hexWords = 0xCAFE_BABE;
     * long maxLong = 0x7fff_ffff_ffff_ffffL;
     * byte nybbles = 0b0010_0101;
     * long bytes = 0b11010010_01101001_10010100_10010010;
 * Вы можете поместить подчеркивание только между цифрами;
 * Вы не можете разместить подчеркивание в следующих местах:
 * - В начале или конце числа
 * - Смежный с десятичной точкой в литерале с плавающей точкой
 * - До суффикса F или L
 * - В позициях, где ожидается строка цифр
 * Следующие примеры демонстрируют допустимые и недействительные
 * размещения подчеркивания (которые выделены) в числовых
 * литералах:
 *  Invalid: cannot put underscores adjacent to a decimal point
 * -  float pi1 = 3_.1415F;
 *  Invalid: cannot put underscores adjacent to a decimal point
 * -  float pi2 = 3._1415F;
 *  Invalid: cannot put underscores prior to an L suffix
 * -  long socialSecurityNumber1 = 999_99_9999_L;
 *
 *  OK (decimal literal)
 * -  int x1 = 5_2;
 *  Invalid: cannot put underscores At the end of a literal
 * -  int x2 = 52_;
 *  OK (decimal literal)
 * -  int x3 = 5_______2;
 *
 *  Invalid: cannot put underscores in the 0x radix prefix
 * -  int x4 = 0_x52;
 *  Invalid: cannot put underscores at the beginning of a number
 * -  int x5 = 0x_52;
 *  OK (hexadecimal literal)
 * -  int x6 = 0x5_2;
 *  Invalid: cannot put underscores at the end of a number
 * -  int x7 = 0x52_;
 */
